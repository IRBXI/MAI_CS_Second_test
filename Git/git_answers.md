# Раздел 1 Git
## Что такое git
Git - система контроля версий, которая помогает отслеживать изменения в файлах. Она необходима, чтобы разработчики могли вместе работать над одним проектом. Также git позволяет в случае непоправимого изменения откатиться назад.
## Команды git
**git add** - команда, которая добавляет в индекс изменения с момента последнего коммита. Изменения в индексе затем можно закоммитить с помощью **git commit**. Для того, чтобы посмотреть, какие изменения были сделаны нужно прописать **git status**. **git fetch** подтягивает из удаленного репозитория информацию о новых коммитах, это необходимо, чтобы прописать **git pull**, который скачивает новые коммиты из удаленного репозитория. **git push** загружает новые коммиты из локального репозитория в удаленный.  **git checkout** переводит указатель HEAD на другую ветку, а флаг **-b** создает новую ветку. **git branch** показывает все ветки в локальном репозитории и помечает ветку, на которой сейчас находится указатель HEAD. **git log** показывает все последние коммиты, их хэши, ветки, в которых они лежат, название и.т.д.
**git cherry-pick** копирует коммит из одной ветки в текущую ветку. `git cherry-pick <commit_hash>`. Хэш коммита можно получить с помощью **git log**. Эта команда также позволяет перемещать сразу несколько коммитов через пробел или `git cherry-pick <start-commit-hash>^..<end-commit-hash>`.
**git reset** откатывает коммиты до указанного коммита. `git reset <commit_hash>`. У него есть 2 режима --soft и --hard. --soft сохраняет рабочую директорию после ресета, а именно закидывает откатанные изменения в индекс. --hard откатывает коммиты, не сохраняя удаленные изменения.
## Работа с ветками в git
Git представляет из себя дерево, в котором находятся коммиты. В этом дереве находится указатель HEAD, который всегда указывает на текущий коммит, и указатели веток. По умолчанию есть только один указатель main, который указывает на последний коммит в этой ветке. Ветка же является ответвлением в дереве. Когда мы создаем ветку с помощью **git checkout -b**, у нас создается указатель на коммит и указатель HEAD перемещается к нему. Далее когда мы делаем **git commit** вместо перемещения ветки main у наш перемещается указатель нашей новой ветки. Помимо изменения указателя при переходе на новую ветку у нас изменяется рабочая директория так, что она совпадает со снимком директории, сохраненном в коммите. 
## Merge конфликты
Мердж конфликты возникают, когда мы хотим слить одну ветку с другой, но git не понимает, как это сделать. Такая ситуация может произойти, например, если один разработчик поменял в текстовом файле строчку, а другой ее в своей ветке удалил. В таком случае при слиянии гит возвращает сообщение с просьбой поправить конфликт и меняет файл с конфликтом: добавляет туда в определенном формате оба изменения и разработчик должен выбрать, какое оставить. Затем нужно сделать git commit, чтобы сделать слияние.
Если же конфликтующих файлов много и вы уверены в своей правоте, можно сделать `git rebase <branch name>`, он переместит начало вашей ветки в конец другой. Затем можно переместится в `branch_name` и сделать `git merge`.
## Локальная копия репозитория...
Локальная копия репозитория - копия репозитория с сервера (например Github) на компьютере. Ее можно получить с помощью `git clone`. Удаленная копия - копия репозитория на сервере. С ней можно взаимодействовать с помощью команд git push, git pull, git fetch. Fork - удаленная копия другого репозитория, она нужна, чтобы сторонние люди (контрибьютеры) могли вносить свой вклад в другие проекты. Работа с форком такая же, как и с обычным репозиторием, но чтобы влить изменения в репозиторий, откуда сделан форк, нужно сделать пул реквест. `git remote add` добавляет новые удаленные репозитории.
## Ой, у меня лишний файл в PR
Удалить файл и сделать git commit или сделать git reset HEAD^ если файл был добавлен в последнем коммите.
## Ой, я нечаянно удалил файл и добавил это в PR
Сделать git reset HEAD^ сделать какие-то изменения и отправить коммит, правда придется сделать push --force, чтобы затереть коммит. Лучшей практикой будет `git revert <commit_hash>`, он создаст новый коммит, который откатит изменения другого.
## Ой, у меня в PR кучу файлов с других веток
Сделать git rebase main, чтобы переместить точку отсчета ветки в ветку main.
## Ой, в PR пишут, что у меня merge-конфликт файла
Исправить merge конфликт, как настоящий сигма. Или сделать git rebase.
## Ой, преподаватель сломал CI... а через час зачем-то попросил меня ’Обновить ветку’...
Сделать git fetch, git pull. Затем в своей ветке сделать git merge main, чтобы перетянуть изменения в свою ветку.