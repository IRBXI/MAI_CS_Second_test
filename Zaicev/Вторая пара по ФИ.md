---
aliases:
  - Зайцев 2
  - 2 пара по ФИ
---

[[Фундаментальная информатика]]
# Система счисления
**Опр**. Способ числовой интерпретации цифровых сообщений. Способ понимать цифровые сообщения.
Способ кодирования $b_{i} \rightarrow b_{0}b_{1}^{i+1}$. может быть положен в основу натуральной системы счисления. Пример: 1-|, 2-||.
$\omega^{*}$ - множество слов из букв алфавита $\omega$ в том числе и пустое слово.
Кардинальная система счисления - система для кодирования натуральных чисел и нуля. Пример: 0-|, 1-||, 2-|||.
Палочки занимают дохера места, поэтому придумали **позиционную систему счисления.**
Позиционная СИ - полиномиальный способ числовой интерпретации слов над цифровым алфавитом.
Позиционная СИ задается одним числом p из N - **основание СИ**. Основание однозначно задает алфавит $A=\{0,1,...,p-1\}$ и интерпретацию  
![[Pasted image 20241213162417.png]]
Длину числа можно получить, если взять логарифм по основанию основания СИ и "округлить вниз".
*ВО ВСЕХ ЛАБОРАТОРКАХ БУДЕТ МАШИННАЯ АРИФМЕТИКА.*
*Книга Фомин СС.(по желанию(не буду делать)).*
Чем больше основание СИ, тем короче запись, тем сложнее запись такого числа(много кнопок на клаве).
**!погуглить BCD - двоично кодированные десятичные(текстовые представления чисел)**
**!Римские числа не позиционны.**
Текстовые представления bullshit. Текстовые представления можно понимать как то, что каждая цифра кодируется как отдельная буква в отдельном машинном слове.
## Представление отрицательного числа
### Алгоритм доп кода
1. Заменить все цифры числа дополнениями до максимальной цифры системы счисления.
2. Прибавить 1
Феликс предложила какой-то способ хранения отриц. числа. Однако отрицательные числа кодируются наоборот(например 3 - `00000011`, а -3 - `11111101`) сделано это, чтобы можно было складывать числа без дополнительной проверки знака. **Доп. код** - дополнение до ближайшей целой степени p на 1 большей чем кол-во разрядов машинного слова.
СТАРШИЙ БИТ НЕ ОТВЕЧАЕТ ЗА ЗНАК #СекретыЗайцева 
## Типичные операции
### Сдвиги
1. Логический(тупо сдвиг битов влево или вправо), один из способов задать направление сдвига - знак(но такое мало где реализовано) или через отдельные команды.
2. Циклический сдвиг(тот же логический сдвиг только числа не выкидываются, а переходят в начало, применяется в криптографии).
3. Арифметический сдвиг(знаковость доп. кода сохраняется, деление или умножение на 2 в зависимости от направления сдвига) - 
## Представление дробных чисел float (потом норм будет написано)
На экзамене будет задача со сложением дробей на си. #СекретыЗайцева
Фиксированная точка в кодировании бредятина.
Конрад Цузе предложил отказаться от фиксированной точки и придумал *плавающую точку* полулогарифмическое композитное представление. Число разбивается на части 
$x = m * p^e$ e из Z. В качестве p используют 2, 8 или 16. m - мантиса. Точку принято хранить в начала мантисы. Первая цифра в мантисе всегда 1, а затем идет . и еще цифры. Благодаря такой мелочи 1 не хранится в машинном слове, мы можем хранить только цифры после точки. Порядок размещается в 3-й части машинного слова. Для его хранения применяется характеристика.
Можно посмотреть точность полулогарифмического представления процессора в описании. #СекретыЗайцева
Точность $10^{-15}$ минимальный стандарт.
# Обработка сообщения
Обработка сообщений определяется правилом обработки $\nu: N\rightarrow N'$, где N - множество сообщений, а $N'$ - множество обработанных сообщений.         
Примеры обработки сообщений: чтение вслух, [[Первая пара по ФИ|кодирование]], перевод с одного языка на другой.
**!Интерпретация - перевод сообщения в информацию.**
**!Обработка - перевод сообщения в другое сообщение.**
Обработка сообщений не мгновенна. Эффективность обработки сообщений измеряется скоростью процесса обработки по сравнению с другими процессами.
# Обработка информации
Обработку информации может делать только человек. Можно обработать сообщение и затем интерпретировать его, чтобы не использовать человека.
![[Pasted image 20241213165122.png]]
$\nu$ - правило обработки сообщений, $\phi$ - интерпретация сообщений. $\sigma$ - соответствие между 2-мя множествами сведений, **не является строго говоря отображением.**
Если $\phi$ обратимо, то можно построить отображение множества сведения $I$ в $I'$. В таком случае правило $\nu$ называют сохраняющим информацию.
Также в таком случае диаграмма коммутативна и правило $\sigma$ называется правилом обработки информации.
Если $\sigma$ обратимое, то обработку сообщений называют перешифровкой.
Если $\nu$ - обратимая перешифровка, то $n'$ кодирует $n$ и процесс обработки называется перекодировкой.
Перешифровка, которая не является обратимой называют **сжимающей**.
Если $\sigma$ необратимое отображение, то обработку сообщений называют **избирательной**.
Обработка информации никогда не добавляет информацию, а извлекает ее из той, что содержится в сообщении.

# Автоматическая обработка информации
Для автоматической обработки информации нужно иметь 3 физических представления: физическое представления для множества сообщение $N$ - $D$ - **множество исходных данных**.
представления множества сообщений $N'$ - $D'$ - множество результирующих данных.
Физическое представление отображения $\nu$ - $P$ - преобразование данных $D$ в $D'$, которое может быть реализуемо на физическом устройстве.
Для того, чтобы выполнять обработку сообщений необходимо автоматизировать выполнение 3-х отображений: кодирование $N \rightarrow D$ - каждому сообщению соответствует конкретное состояние устройства; отображение $P$ и отображение $D' \rightarrow N'$ - декодирование.
# Конструктивное процесса обработки дискретных сообщений
Чтобы отображение $P$ из множества данных $D$ в множество данных $D'$ могло быть автоматизировано, оно должно представлять из себя способ построения сообщения $d' = P(d)$. Если множество $D$ небольшое, то отображение $P$ можно сделать с помощью таблицы, но если $D$ очень большое или бесконечное, то $P$ должно представлять из себя последовательность **тактов**, каждый из которых должен являться простым отображением, называемым **операцией**.
**Алгоритм** - точно заданная последовательность правил, указывающая каким образом можно за конечное число шагов получить выходное сообщение определенного вида.
# Свойства алгоритма
1. **Массовость** - потенциальная бесконечность исходных сообщений
2. **Детерминированность** - последовательное выполнение дискретных действий однозначно определяемых результатами предыдущего шага.
3. Элементарность каждого шага
4. Результативность - точное описание того, что считается результатом алгоритма.
5. Сложность алгоритма - кол-во простых операций, которые нужно совершить для обработки сообщения. Оно зависит от длины сообщения.
Про сложность алгоритма писать не буду, это база.

